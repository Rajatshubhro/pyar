#!/usr/bin/env python3
# encoding: utf-8
"""Command line interface for PyAR"""
import argparse
import datetime
import logging
import os
import sys
import time
from collections import defaultdict

import numpy as np

from pyar import reactor, tabu, aggregator, optimiser, Molecule
from pyar.data import defualt_parameters

logger = logging.getLogger('pyar')
handler = logging.FileHandler('pyar.log', 'w')


def argument_parse():
    """ Parse command line arguments
    :return: argparse object
    """
    parser = argparse.ArgumentParser(prog='PyAR', description='PyAR is a \
             program to predict aggregation, reaction, clustering.  \
             There are also modules for stochastic generation of  \
             orientations of two more molecules and atoms')

    parser.add_argument('-v', '--verbosity',
                        choices=[0, 1, 2, 3, 4], type=int,
                        help="increase output verbosity (0=Debug; 1=Info; "
                             "2: Warning; 3: Error; 4: Critical)")

    parser.add_argument("input_files", metavar='files',
                        type=str, nargs='+',
                        help='input coordinate files')

    parser.add_argument('-N', dest='how_many_orientations', metavar='N',
                        required=True,
                        help='how many orientations to be used')

    run_type_group = parser.add_mutually_exclusive_group(required=True)

    run_type_group.add_argument("-r", "--react",
                                help="Run a reactor calculation",
                                action='store_true')

    run_type_group.add_argument("-s", "--solvate",
                                help="Add one solvent molecules to given solute molecules",
                                action='store_true')

    run_type_group.add_argument("-a", "--aggregate",
                                help="Run a aggregator calculation",
                                action='store_true')

    run_type_group.add_argument("--scan-bond", nargs=2, type=int, metavar=('a', 'b'),
                                help="scan a bond between the given atoms of two"
                                     "fragments")

    scan_group = parser.add_argument_group('scan', 'Scan specific options')

    aggregator_group = parser.add_argument_group('aggregator',
                                                 'Aggregator specific options')

    aggregator_group.add_argument('-ss', '--solvation-size', type=int, metavar='n',
                                  help='number of solvent molecules to be added')

    aggregator_group.add_argument('-mns', '--maximum-number-of-seeds', metavar='n',
                                  type=int,
                                  help='maximum number of seeds')

    aggregator_group.add_argument('-as', '--aggregate-size', type=int, nargs='*',
                                  metavar=('l', 'm',),
                                  help='number of monomers in aggregate')

    aggregator_group.add_argument('--first-pathway', type=int, metavar='l',
                                  help='The first pathway among all the '
                                       'possible aggregation paths in '
                                       'binary or ternary aggregation.')

    aggregator_group.add_argument('--number-of-pathways', type=int, metavar='n',
                                  help='How many pathways to be used in '
                                       'binary/ternary aggregation.')

    reactor_group = parser.add_argument_group('reactor',
                                              'Reactor specific option')

    reactor_group.add_argument('-gmin', type=float,
                               help='minimum value of gamma')

    reactor_group.add_argument('-gmax', type=float,
                               help='maximum value of gamma')

    reactor_group.add_argument('--site', type=int, nargs=2,
                               help='atom for site specific reaction')

    molecule_group = parser.add_argument_group('molecule',
                                               'Options related to the electronic'
                                               ' structure of the molecule')

    molecule_group.add_argument("-c", "--charge", type=int, nargs='+',
                                required=True, metavar='c',
                                help="Charge of the system")

    molecule_group.add_argument("-m", "--multiplicity", type=int, nargs='+',
                                required=True, metavar='m',
                                help="Multiplicity of the system")

    molecule_group.add_argument("--scftype", type=str, nargs='+',
                                help="specify rhf or uhf (default=rhf)")

    quantum_chemistry_group = parser.add_argument_group('calculation',
                                                        'Calculation specific options')

    quantum_chemistry_group.add_argument("--software", type=str,
                                         choices=['gaussian', 'mopac', 'obabel', 'orca',
                                                  'psi4', 'turbomole', 'xtb',
                                                  'xtb_turbo'],
                                         required=True, help="Software")

    quantum_chemistry_group.add_argument('-basis', '--basis', type=str,
                                         help='Basis set (default=def2-SVP)')

    quantum_chemistry_group.add_argument('-method', '--method', type=str,
                                         help='The method (default=BP86)')

    quantum_chemistry_group.add_argument('--opt-threshold', type=str, default='normal',
                                         choices=['loose', 'normal', 'tight'],
                                         help='Optimization threshold')

    quantum_chemistry_group.add_argument('--opt-cycles', type=int, default=100,
                                         help='Maximum optimization cycles')

    quantum_chemistry_group.add_argument('--scf-threshold', type=str, default='normal',
                                         choices=['loose', 'normal', 'tight'],
                                         help='SCF threshold')

    quantum_chemistry_group.add_argument('--scf-cycles', type=int, default=1000,
                                         help='Maximum SCF cycles.')

    return parser.parse_args()


# noinspection PyTypeChecker
def main():
    """
    Process the parameters, setups the jobs and executes.
    """

    args = vars(argument_parse())

    run_parameters = defaultdict(lambda: None, defualt_parameters.values)

    for key, value in args.items():
        if args[key] is not None and run_parameters[key] != args[key]:
            run_parameters[key] = args[key]

    if run_parameters['verbosity'] == 0:
        logger.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(name)-12s %(filename)s %(funcName)s '
                                      '%(lineno)d %(levelname)-8s: %(message)s')
    elif run_parameters['verbosity'] == 1:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.INFO)
    elif run_parameters['verbosity'] == 2:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.WARNING)
    elif run_parameters['verbosity'] == 3:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.ERROR)
    elif run_parameters['verbosity'] == 4:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.CRITICAL)
    else:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.CRITICAL)

    handler.setFormatter(formatter)
    logger.addHandler(handler)

    time_now = datetime.datetime.now().strftime("%d %b %Y, %H:%M:%S")
    logger.info(f'Starting PyAR at {time_now}')
    logger.info(f'Job directory: {os.getcwd()}')
    logger.debug(f'Logging level is {{{logger.level}}}')

    logger.debug(f'Parsed arguments are:')

    for k, v in args.items():
        if v:
            logger.debug(f"{k:25} = {v}")

    logger.debug(f'Full parameters are:')
    for k, v in run_parameters.items():
        if v:
            logger.debug(f"{k:25} = {v}")

    # Sanity check
    number_of_input_files = len(run_parameters['input_files'])
    print(f"{number_of_input_files}")

    charges = run_parameters['charge']
    number_of_charge_arguments = len(charges)
    print(f"{number_of_charge_arguments}")
    if number_of_charge_arguments != number_of_input_files:
        message = f"Charges are not specified for all input files"
        print(message)
        sys.exit(message)

    multiplicities = run_parameters['multiplicity']
    number_of_multiplicity_arguments = len(multiplicities)
    print(f"{number_of_multiplicity_arguments}")
    if number_of_multiplicity_arguments != number_of_input_files:
        message = f"Multiplicities are not specified for all input files"
        print(message)
        sys.exit(message)

    scftypes = run_parameters['scftype']
    if scftypes is None:
        scftypes = ['rhf' for _ in range(number_of_input_files)]
    if len(scftypes) != number_of_input_files:
        message = f"SCF Types are not specified for all input files"
        print(message)
        sys.exit(message)
    print(f"SCF types: {scftypes}")

    logger.info("Parsing the following files: ")
    input_molecules = []
    # noinspection PyTypeChecker
    for i in charges:
        print(i)
    for i in multiplicities:
        print(i)
    for each_file, charge, multiplicity in \
            zip(run_parameters['input_files'], charges, multiplicities):
        try:
            mol = Molecule.Molecule.from_xyz(each_file)
            logger.info(f"    {each_file}")
            mol.charge = charge
            mol.multiplicity = multiplicity
            input_molecules.append(mol)
        except IOError:
            logger.critical(f"File {each_file} does not exist")
            sys.exit()

    logger.info(f'Charge:        {run_parameters["charge"]}')
    logger.info(f'Multiplicity:  {run_parameters["multiplicity"]}')
    logger.info(f'SCF Type:      {run_parameters["scftype"]}')

    quantum_chemistry_parameters = {
        'basis': run_parameters['basis'],
        'method': run_parameters['method'],
        'software': run_parameters['software'],
        'opt_cycles': run_parameters['opt_cycles'],
        'opt_threshold': run_parameters['opt_threshold'],
        'scf_cycles': run_parameters['scf_cycles'],
        'scf_threshold': run_parameters['scf_threshold']
    }

    logger.info(f'QM Software:   {quantum_chemistry_parameters["software"]}')

    number_of_orientations = run_parameters['how_many_orientations']
    logger.info(f'{number_of_orientations} orientations will be used')

    maximum_number_of_seeds = run_parameters['maximum_number_of_seeds']

    logger.info(f'{number_of_orientations} orientations will be used')

    if run_parameters['aggregate']:
        size_of_aggregate = run_parameters['aggregate_size']
        if size_of_aggregate is None:
            message = f"Error: For an Aggregation run, specify \n" \
                      f"the desired number of each monomers to be added \n" \
                      f"using the argument\n" \
                      f" -as <int> <int> ..."
            print(size_of_aggregate)
            logger.critical(message)
            sys.exit(message)

        number_of_aggregate_size_arguments = len(size_of_aggregate)
        print(f"{number_of_aggregate_size_arguments}")

        seeds = input_molecules

        t1_0 = time.time()
        time_started = datetime.datetime.now()
        aggregator.aggregate(seeds, size_of_aggregate,
                             number_of_orientations,
                             quantum_chemistry_parameters,
                             maximum_number_of_seeds,
                             run_parameters['first_pathway'],
                             run_parameters['number_of_pathways'])

        logger.info('Total Time: {}'.format(time.time() - t1_0))
        logger.info("Started at {}\nEnded at {}".format(time_started, datetime.datetime.now()))

    if run_parameters['solvate']:
        number_of_solvent_molecules = run_parameters['solvation_size']
        if number_of_solvent_molecules is None:
            message = f'For this please provide the number of solvent\n' \
                      f'molecules to be added. Use the following option\n' \
                      f'  -ss <int>'

            logger.error(message)
            sys.exit(message)

        if len(input_molecules) == 1:
            message = f"Please provide more than two molecules.\n" \
                      f"The last input file will be considered as solvent\n" \
                      f"and the other molecules as solutes to which solvent\n" \
                      f"molecules will be added."
            logger.error(message)
            sys.exit(message)
        else:
            monomer = input_molecules[-1]
            seeds = input_molecules[:-1]

        t1_0 = time.time()
        time_started = datetime.datetime.now()
        aggregator.solvate(seeds, monomer,
                           number_of_solvent_molecules,
                           number_of_orientations,
                           quantum_chemistry_parameters,
                           maximum_number_of_seeds)

        logger.info('Total Time: {}'.format(time.time() - t1_0))
        logger.info("Started at {}\nEnded at {}".format(time_started, datetime.datetime.now()))

    if run_parameters['react']:
        minimum_gamma = run_parameters['gmin']
        maximum_gamma = run_parameters['gmax']
        if len(input_molecules) == 1:
            logger.error('Reactor requires at least two molecules')
            sys.exit('Missing arguments: provide at least two molecules')
        if minimum_gamma is None or maximum_gamma is None:
            logger.error('For a Reactor run specify the '
                         'values of gamma_min and gamma_max using \n'
                         '-gmin <integer> -gmax <integer>')
            sys.exit('missing arguments: -gmin <integer> -gmax <integer>')
        if number_of_orientations is None:
            logger.error("For reaction, specify how many orientations"
                         "are to be used, by the argument\n"
                         "-number_of_orientations <number of orientations>")
            sys.exit('Missing arguments: -N #')

        if run_parameters['site'] is None:
            site = None
            proximity_factor = 2.3
        else:
            site = run_parameters['site']
            proximity_factor = 2.3
            site = [site[0], input_molecules[0].number_of_atoms + site[1]]

        zero_time = time.time()
        time_started = datetime.datetime.now()
        reactor.react(input_molecules[0], input_molecules[1],
                      minimum_gamma, maximum_gamma,
                      int(number_of_orientations),
                      quantum_chemistry_parameters,
                      site, proximity_factor)
        logger.info('Total run time: {}'.format(time.time() - zero_time))
        logger.info("Started at {}\nEnded at {}".format(time_started, datetime.datetime.now()))
        return

    if run_parameters['scan_bond']:
        site_atoms = run_parameters['scan_bond']
        a_molecule = input_molecules[0]
        b_molecule = input_molecules[1]
        a_atom = site_atoms[0]
        b_atom = a_molecule.number_of_atoms + a_atom
        if number_of_orientations is None:
            logger.error("For aggregation, specify how many orientations"
                         "are    to be used, by the argument\n"
                         "-N <number of orientations>")
            sys.exit('Missing arguments: -N #')

        # noinspection PyTypeChecker
        number_of_orientations = int(number_of_orientations)
        input_molecules = tabu.generate_guess_for_bonding('abc',
                                                          a_molecule, b_molecule,
                                                          a_atom, b_atom,
                                                          int(number_of_orientations))

        for each_molecule in input_molecules:
            coordinates = each_molecule.coordinates
            start_dist = np.linalg.norm(coordinates[a_atom] - coordinates[b_atom])
            final_distance = each_molecule.covalent_radius[a_atom] + each_molecule.covalent_radius[b_atom]
            step = int(abs(final_distance - start_dist) * 10)
            if run_parameters['software'] == 'orca':
                c_k = '\n!ScanTS\n% geom scan B ' + str(a_atom) + ' ' + str(b_atom) + \
                      '= ' + str(start_dist) + ', ' + str(final_distance) + \
                      ', ' + str(step) + ' end end\n'

                optimiser.optimise(each_molecule, quantum_chemistry_parameters, 0.0,
                                   custom_keyword=c_k)
            else:
                logger.error('Optimization with %s is not implemented '
                             'yet' % run_parameters['software'])

    return


if __name__ == "__main__":
    main()
