#!/usr/bin/env python3
# encoding: utf-8
"""Command line interface for PyAR"""
import argparse
import datetime
import logging
import os
import sys
import time
from collections import defaultdict

import numpy as np

from pyar import reactor, tabu, aggregator, optimiser, Molecule
from pyar.data import defualt_parameters

logger = logging.getLogger('pyar')
handler = logging.FileHandler('pyar.log', 'w')


def argument_parse():
    """ Parse command line arguments
    :return: argparse object
    """
    parser = argparse.ArgumentParser(prog='PyAR', description='PyAR is a \
             program to predict aggregation, reaction, clustering.  \
             There are also modules for stochastic generation of  \
             orientations of two more molecules and atoms')

    parser.add_argument('-v', '--verbosity',
                        choices=[0, 1, 2, 3, 4], type=int,
                        help="increase output verbosity (0=Debug; 1=Info; "
                             "2: Warning; 3: Error; 4: Critical)")

    parser.add_argument("input_files", metavar='files',
                        type=str, nargs='+',
                        help='input coordinate files')

    parser.add_argument('-N', dest='how_many_orientations',
                        help='how many orientations to be used')

    run_type_group = parser.add_mutually_exclusive_group(required=True)

    run_type_group.add_argument("-r", "--react",
                                help="Run a reactor calculation",
                                action='store_true')

    run_type_group.add_argument("-a", "--aggregate",
                                help="Run a aggregator calculation",
                                action='store_true')

    run_type_group.add_argument("-na", "--new-aggregate",
                                help="Run a aggregator calculation",
                                action='store_true')

    run_type_group.add_argument("-ba", "--binary-aggregate",
                                help="Run a binary aggregation",
                                action='store_true')

    run_type_group.add_argument("-ta", "--ternary-aggregate",
                                help="Run a ternary aggregation",
                                action='store_true')

    run_type_group.add_argument("--scan-bond", nargs=2, type=int,
                                help="scan a bond between the given atoms of two"
                                     "fragments")

    new_aggregator_group = parser.add_argument_group('scan', 'Scan specific options')

    new_aggregator_group = parser.add_argument_group('new_aggregator',
                                                     'New aggregator specific options')

    new_aggregator_group.add_argument('-nas', '--new-aggregate-size', type=int, nargs='*',
                                      help='number of monomers in aggregate')

    aggregator_group = parser.add_argument_group('aggregator',
                                                 'Aggregator specific option')

    aggregator_group.add_argument('-as', '--aggregate-size', type=int,
                                  help='number of monomers in aggregate')

    aggregator_group.add_argument('-mns', '--maximum-number-of-seeds',
                                  type=int,
                                  help='maximum number of seeds')

    composite_aggregator_group = parser.add_argument_group('composite_aggregator',
                                                           'Binary_and Ternary '
                                                           'aggregator specific '
                                                           'option')

    composite_aggregator_group.add_argument('-fa', '--size-of-fragment-one',
                                            type=int, help='size of atom1')

    composite_aggregator_group.add_argument('-fb', '--size-of-fragment-two',
                                            type=int, help='size of atom2')

    composite_aggregator_group.add_argument('-fc', '--size-of-fragment-three',
                                            type=int, help='size of atom3')

    composite_aggregator_group.add_argument('--first-pathway', type=int,
                                            help='The first pathway among all the '
                                                 'possible aggregation paths in '
                                                 'binary or ternary aggregation.')

    composite_aggregator_group.add_argument('--number-of-pathways', type=int,
                                            help='How many pathways to be used in '
                                                 'binary/ternary aggregation.')

    reactor_group = parser.add_argument_group('reactor',
                                              'Reactor specific option')

    reactor_group.add_argument('-gmin', type=float,
                               help='minimum value of gamma')

    reactor_group.add_argument('-gmax', type=float,
                               help='maximum value of gamma')

    reactor_group.add_argument('--site', type=int, nargs=2,
                               help='atom for site specific '
                                    'aggregation/solvation')

    molecule_group = parser.add_argument_group('molecule',
                                               'Options related to the electronic'
                                               ' structure of the molecule')

    molecule_group.add_argument("-c", "--charge", type=int,
                                help="Charge of the system")

    molecule_group.add_argument("-m", "--multiplicity", type=int,
                                help="Multiplicity of the system")

    molecule_group.add_argument("--scftype", type=str, choices=['rhf', 'uhf'],
                                help="specify rhf or uhf (default=rhf)")

    qm_setup_group = parser.add_argument_group('calculation',
                                               'Calculation specific options')

    qm_setup_group.add_argument("--software", type=str,
                                choices=['mopac', 'obabel', 'orca', 'psi4',
                                         'turbomole', 'xtb', 'xtb_turbo'],
                                required=True, help="Software")

    qm_setup_group.add_argument('-basis', '--basis', type=str,
                                help='Basis set (default=def2-SVP)')

    qm_setup_group.add_argument('-method', '--method', type=str,
                                help='The method (default=BP86)')

    return parser.parse_args()


# noinspection PyTypeChecker
def main():
    """
    Process the parameters, setups the jobs and executes.
    """

    args = vars(argument_parse())

    run_parameters = defaultdict(lambda: None, defualt_parameters.values)

    for key, value in args.items():
        if args[key] is not None and run_parameters[key] != args[key]:
            run_parameters[key] = args[key]

    if run_parameters['verbosity'] == 0:
        logger.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(name)-12s %(filename)s %(funcName)s '
                                      '%(lineno)d %(levelname)-8s: %(message)s')
    elif run_parameters['verbosity'] == 1:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.INFO)
    elif run_parameters['verbosity'] == 2:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.WARNING)
    elif run_parameters['verbosity'] == 3:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.ERROR)
    elif run_parameters['verbosity'] == 4:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.CRITICAL)
    else:
        formatter = logging.Formatter('%(message)s')
        logger.setLevel(logging.CRITICAL)

    handler.setFormatter(formatter)
    logger.addHandler(handler)

    logger.info(f'Starting PyAR at {datetime.datetime.now().strftime("%d %b %Y, %H:%M:%S")}')
    logger.info(f'Job directory: {os.getcwd()}')
    logger.debug(f'Logging level is {{{logger.level}}}')
    logger.debug(f'Parsed arguments {args}')

    logger.info("Parsing the following files: ")

    input_molecules = []
    for each_file in run_parameters['input_files']:
        try:
            mol = Molecule.Molecule.from_xyz(each_file)
            logger.info(f"    {each_file}")
            for prop in ['charge', 'multiplicity', 'scftype', 'software']:
                vars(mol)[prop] = run_parameters[prop]
            input_molecules.append(mol)
        except IOError:
            logger.critical(f"File {each_file} does not exist")
            sys.exit()

    logger.debug("The arguments are:")
    logger.debug(args)
    logger.info(f'Charge:        {run_parameters["charge"]}')
    logger.info(f'Multiplicity:  {run_parameters["multiplicity"]}')
    logger.info(f'SCF Type:      {run_parameters["scftype"]}')

    method_args = {
        'basis': run_parameters['basis'],
        'method': run_parameters['method'],
        'software': run_parameters['software']
    }

    logger.info(f'QM Software:   {method_args["software"]}')

    number_of_orientations = run_parameters['how_many_orientations']
    logger.info(f'{number_of_orientations} orientations will be used')

    maximum_number_of_seeds = run_parameters['maximum_number_of_seeds']

    if run_parameters['new_aggregate']:
        new_size_of_aggregate = run_parameters['new_aggregate_size']
        if new_size_of_aggregate is None:
            logger.error('For an Aggregation run '
                         'specify the aggregate size '
                         '(number of monomers to be added) '
                         'using the argument\n -as <integer>')
            sys.exit('Missing arguments: -as #')

        if number_of_orientations is None:
            logger.error("For aggregation, specify how many orientations"
                         "are to be used, by the argument\n"
                         "-number_of_orientations <number of orientations>")
            sys.exit('Missing arguments: -N #')
        #
        # if len(input_molecules) == 1:
        #     logger.error('Provide at least two files')
        #     sys.exit('Missing arguments: Provide at least two files')
        # else:
        #     seeds = input_molecules

        seeds = input_molecules

        t1_0 = time.time()
        time_started = datetime.datetime.now()
        aggregator.new_aggregate(seeds, new_size_of_aggregate,
                                 number_of_orientations,
                                 method_args,
                                 maximum_number_of_seeds,
                                 run_parameters['first_pathway'],
                                 run_parameters['number_of_pathways'])

        logger.info('Total Time: {}'.format(time.time() - t1_0))
        logger.info("Started at {}\nEnded at {}".format(time_started, datetime.datetime.now()))

    if run_parameters['aggregate']:
        size_of_aggregate = run_parameters['aggregate_size']
        if size_of_aggregate is None:
            logger.error('For an Aggregation run '
                         'specify the aggregate size '
                         '(number of monomers to be added) '
                         'using the argument\n -as <integer>')
            sys.exit('Missing arguments: -as #')

        if number_of_orientations is None:
            logger.error("For aggregation, specify how many orientations"
                         "are to be used, by the argument\n"
                         "-number_of_orientations <number of orientations>")
            sys.exit('Missing arguments: -N #')

        if len(input_molecules) == 1:
            logger.error('Provide at least two files')
            sys.exit('Missing arguments: Provide at least two files')
        else:
            monomer = input_molecules[-1]
            seeds = input_molecules[:-1]

        t1_0 = time.time()
        time_started = datetime.datetime.now()
        aggregator.aggregate(seeds, monomer,
                             aggregate_size=size_of_aggregate,
                             hm_orientations=number_of_orientations,
                             method=method_args, maximum_number_of_seeds=maximum_number_of_seeds)

        logger.info('Total Time: {}'.format(time.time() - t1_0))
        logger.info("Started at {}\nEnded at {}".format(time_started, datetime.datetime.now()))

    if run_parameters['binary_aggregate']:
        number_of_fragment_one = run_parameters['size_of_fragment_one']
        number_of_fragment_two = run_parameters['size_of_fragment_two']
        if number_of_fragment_one is None or number_of_fragment_two is None:
            logger.error("For binary aggregation, specify aggregate size of"
                         " moiety 1 and 2 as <integers>")
            sys.exit("For binary aggregation, specify aggregate size of"
                     " moiety 1 and 2 as <integers>")
        if number_of_orientations is None:
            logger.error("Any aggregation requires the number of orientations"
                         " to be used")
            sys.exit("provide the number of orientations (-N #)")
        if len(input_molecules) == 1:
            logger.error("For binary aggregation, provide two moieties")
        else:
            seed_a = input_molecules[:-1]
            seed_b = input_molecules[-1:]
            logger.debug(seed_a)
            logger.debug(seed_b)
            zero_time = time.time()
            time_started = datetime.datetime.now()
            aggregator.exhaustive_binary_aggregate(seed_a, seed_b, number_of_fragment_one,
                                                   number_of_fragment_two,
                                                   number_of_orientations,
                                                   method_args,
                                                   maximum_number_of_seeds,
                                                   run_parameters['first_pathway'],
                                                   run_parameters['number_of_pathways'])

            logger.info('Total Time: {}'.format(time.time() - zero_time))
            logger.info("Started at {}\nEnded at {}".format(time_started, datetime.datetime.now()))

    if run_parameters['ternary_aggregate']:
        number_of_fragment_one = run_parameterssize_of_fragment_one
        number_of_fragment_two = run_parameters['size_of_fragment_two']
        number_of_fragment_three = run_parameters['size_of_fragment_three']
        if number_of_fragment_one is None or \
                number_of_fragment_two is None or \
                number_of_fragment_three is None:
            logger.error("For binary aggregation, specify aggregate size of"
                         " moiety 1, 2, and 3 as <integers>")
            sys.exit("For binary aggregation, specify aggregate size of"
                     " moiety 1,2, and 3 as <integers>")
        if number_of_orientations is None:
            logger.error("Any aggregation requires the number of orientations"
                         " to be used")
            sys.exit("provide the number of orientations (-N #)")
        if len(input_molecules) != 3:
            logger.error("For ternary aggregation, provide three moieties")
        else:
            seed_a = [input_molecules[0]]
            seed_b = [input_molecules[1]]
            seed_c = [input_molecules[2]]
            logger.debug(seed_a)
            logger.debug(seed_b)
            logger.debug(seed_c)
            zero_time = time.time()
            time_started = datetime.datetime.now()
            aggregator.exhaustive_ternary_aggregate(seed_a, seed_b, seed_c,
                                                    number_of_fragment_one,
                                                    number_of_fragment_two,
                                                    number_of_fragment_three,
                                                    hm_orientations=number_of_orientations,
                                                    method=method_args,
                                                    maximum_number_of_seeds=maximum_number_of_seeds)

        logger.info('Total Time: {}'.format(time.time() - zero_time))
        logger.info("Started at {}\nEnded at {}".format(time_started, datetime.datetime.now()))

    if run_parameters['react']:
        minimum_gamma = run_parameters['gmin']
        maximum_gamma = run_parameters['gmax']
        if len(input_molecules) == 1:
            logger.error('Reactor requires at least two molecules')
            sys.exit('Missing arguments: provide at least two molecules')
        if minimum_gamma is None or maximum_gamma is None:
            logger.error('For a Reactor run specify the '
                         'values of gamma_min and gamma_max using \n'
                         '-gmin <integer> -gmax <integer>')
            sys.exit('missing arguments: -gmin <integer> -gmax <integer>')
        if number_of_orientations is None:
            logger.error("For reaction, specify how many orientations"
                         "are to be used, by the argument\n"
                         "-number_of_orientations <number of orientations>")
            sys.exit('Missing arguments: -N #')

        if run_parameters['site'] is None:
            site = None
            proximity_factor = 2.3
        else:
            site = run_parameter['site']
            proximity_factor = 2.3
            site = [site[0], input_molecules[0].number_of_atoms + site[1]]

        zero_time = time.time()
        time_started = datetime.datetime.now()
        reactor.react(input_molecules[0], input_molecules[1],
                      gamma_min=minimum_gamma, gamma_max=maximum_gamma,
                      hm_orientations=number_of_orientations,
                      method=method_args,
                      site=site, proximity_factor=proximity_factor)
        logger.info('Total run time: {}'.format(time.time() - zero_time))
        logger.info("Started at {}\nEnded at {}".format(time_started, datetime.datetime.now()))
        return

    if run_parameters['scan_bond']:
        a = run_parameters['scan_bond'][0]
        b = input_molecules[0].number_of_atoms + run_parameters['scan_bond'][1]
        if number_of_orientations is None:
            logger.error("For aggregation, specify how many orientations"
                         "are    to be used, by the argument\n"
                         "-N <number of orientations>")
            sys.exit('Missing arguments: -N #')

        # noinspection PyTypeChecker
        number_of_orientations = int(number_of_orientations)
        input_molecules = tabu.generate_guess_for_bonding('abc', input_molecules[0],
                                                          input_molecules[1], a, b,
                                                          int(number_of_orientations))
        for each_molecule in input_molecules:
            coordinates = each_molecule.coordinates
            start_dist = np.linalg.norm(coordinates[a] - coordinates[b])
            final_distance = each_molecule.covalent_radius[a] \
                             + each_molecule.covalent_radius[b]
            step = int(abs(final_distance - start_dist) * 10)
            if run_parameters['software'] == 'orca':
                c_k = '\n!ScanTS\n% geom scan B ' + str(a) + ' ' + str(b) + \
                      '= ' + str(start_dist) + ', ' + str(final_distance) + \
                      ', ' + str(step) + ' end end\n'

                optimiser.optimise(each_molecule, method_args, 0.0,
                                   custom_keyword=c_k)
            else:
                logger.error('Optimization with %s is not implemented '
                             'yet' % run_parameters['software'])


if __name__ == "__main__":
    main()
